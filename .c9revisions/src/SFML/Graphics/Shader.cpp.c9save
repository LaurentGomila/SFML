{"ts":1369222496441,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"////////////////////////////////////////////////////////////\r\n//\r\n// SFML - Simple and Fast Multimedia Library\r\n// Copyright (C) 2007-2013 Laurent Gomila (laurent.gom@gmail.com)\r\n//\r\n// This software is provided 'as-is', without any express or implied warranty.\r\n// In no event will the authors be held liable for any damages arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it freely,\r\n// subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented;\r\n//    you must not claim that you wrote the original software.\r\n//    If you use this software in a product, an acknowledgment\r\n//    in the product documentation would be appreciated but is not required.\r\n//\r\n// 2. Altered source versions must be plainly marked as such,\r\n//    and must not be misrepresented as being the original software.\r\n//\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n//\r\n////////////////////////////////////////////////////////////\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\n// Headers\r\n////////////////////////////////////////////////////////////\r\n#include <SFML/Graphics/Shader.hpp>\r\n#include <SFML/Graphics/Texture.hpp>\r\n#include <SFML/Graphics/GLCheck.hpp>\r\n#include <SFML/System/InputStream.hpp>\r\n#include <SFML/System/Err.hpp>\r\n#include <fstream>\r\n#include <vector>\r\n\r\n\r\nnamespace\r\n{\r\n    // Retrieve the maximum number of texture units available\r\n    GLint getMaxTextureUnits()\r\n    {\r\n        GLint maxUnits;\r\n        glCheck(glGetIntegerv(GL_MAX_TEXTURE_COORDS_ARB, &maxUnits));\r\n        return maxUnits;\r\n    }\r\n\r\n    // Read the contents of a file into an array of char\r\n    bool getFileContents(const std::string& filename, std::vector<char>& buffer)\r\n    {\r\n        std::ifstream file(filename.c_str(), std::ios_base::binary);\r\n        if (file)\r\n        {\r\n            file.seekg(0, std::ios_base::end);\r\n            std::streamsize size = file.tellg();\r\n            if (size > 0)\r\n            {\r\n                file.seekg(0, std::ios_base::beg);\r\n                buffer.resize(static_cast<std::size_t>(size));\r\n                file.read(&buffer[0], size);\r\n            }\r\n            buffer.push_back('\\0');\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Read the contents of a stream into an array of char\r\n    bool getStreamContents(sf::InputStream& stream, std::vector<char>& buffer)\r\n    {\r\n        bool success = true;\r\n        sf::Int64 size = stream.getSize();\r\n        if (size > 0)\r\n        {\r\n            buffer.resize(static_cast<std::size_t>(size));\r\n            stream.seek(0);\r\n            sf::Int64 read = stream.read(&buffer[0], size);\r\n            success = (read == size);\r\n        }\r\n        buffer.push_back('\\0');\r\n        return success;\r\n    }\r\n}\r\n\r\n\r\nnamespace sf\r\n{\r\n////////////////////////////////////////////////////////////\r\nShader::CurrentTextureType Shader::CurrentTexture;\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nShader::Shader() :\r\nm_shaderProgram (0),\r\nm_currentTexture(-1)\r\n{\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nShader::~Shader()\r\n{\r\n    ensureGlContext();\r\n\r\n    // Destroy effect program\r\n    if (m_shaderProgram)\r\n        glCheck(glDeleteObjectARB(m_shaderProgram));\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::loadFromFile(const std::string& filename, Type type)\r\n{\r\n    // Read the file\r\n    std::vector<char> shader;\r\n    if (!getFileContents(filename, shader))\r\n    {\r\n        err() << \"Failed to open shader file \\\"\" << filename << \"\\\"\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Compile the shader program\r\n    if (type == Vertex)\r\n        return compile(&shader[0], NULL);\r\n    else\r\n        return compile(NULL, &shader[0]);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::loadFromFile(const std::string& vertexShaderFilename, const std::string& fragmentShaderFilename)\r\n{\r\n    // Read the vertex shader file\r\n    std::vector<char> vertexShader;\r\n    if (!getFileContents(vertexShaderFilename, vertexShader))\r\n    {\r\n        err() << \"Failed to open vertex shader file \\\"\" << vertexShaderFilename << \"\\\"\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Read the fragment shader file\r\n    std::vector<char> fragmentShader;\r\n    if (!getFileContents(fragmentShaderFilename, fragmentShader))\r\n    {\r\n        err() << \"Failed to open fragment shader file \\\"\" << fragmentShaderFilename << \"\\\"\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Compile the shader program\r\n    return compile(&vertexShader[0], &fragmentShader[0]);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::loadFromMemory(const std::string& shader, Type type)\r\n{\r\n    // Compile the shader program\r\n    if (type == Vertex)\r\n        return compile(shader.c_str(), NULL);\r\n    else\r\n        return compile(NULL, shader.c_str());\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::loadFromMemory(const std::string& vertexShader, const std::string& fragmentShader)\r\n{\r\n    // Compile the shader program\r\n    return compile(vertexShader.c_str(), fragmentShader.c_str());\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::loadFromStream(InputStream& stream, Type type)\r\n{\r\n    // Read the shader code from the stream\r\n    std::vector<char> shader;\r\n    if (!getStreamContents(stream, shader))\r\n    {\r\n        err() << \"Failed to read shader from stream\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Compile the shader program\r\n    if (type == Vertex)\r\n        return compile(&shader[0], NULL);\r\n    else\r\n        return compile(NULL, &shader[0]);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::loadFromStream(InputStream& vertexShaderStream, InputStream& fragmentShaderStream)\r\n{\r\n    // Read the vertex shader code from the stream\r\n    std::vector<char> vertexShader;\r\n    if (!getStreamContents(vertexShaderStream, vertexShader))\r\n    {\r\n        err() << \"Failed to read vertex shader from stream\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Read the fragment shader code from the stream\r\n    std::vector<char> fragmentShader;\r\n    if (!getStreamContents(fragmentShaderStream, fragmentShader))\r\n    {\r\n        err() << \"Failed to read fragment shader from stream\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Compile the shader program\r\n    return compile(&vertexShader[0], &fragmentShader[0]);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, int x)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Enable program\r\n        GLint program;\r\n        glGetIntegerv(GL_CURRENT_PROGRAM, &program);\r\n\r\n        bool notActiveProgram = (static_cast<unsigned int>(program) != m_shaderProgram);\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(m_shaderProgram)));\r\n\r\n        // Get parameter location and assign it new values\r\n        GLint location = static_cast<GLint>(getParamLocation(name));\r\n        if (location != -1)\r\n            glCheck(glUniform1iARB(location, x));\r\n        else\r\n            err() << \"Parameter \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n\r\n        // Disable program\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(program)));\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, float x)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Enable program\r\n        GLint program;\r\n        glGetIntegerv(GL_CURRENT_PROGRAM, &program);\r\n\r\n        bool notActiveProgram = (static_cast<unsigned int>(program) != m_shaderProgram);\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(m_shaderProgram)));\r\n\r\n        // Get parameter location and assign it new values\r\n        GLint location = static_cast<GLint>(getParamLocation(name));\r\n        if (location != -1)\r\n            glCheck(glUniform1fARB(location, x));\r\n        else\r\n            err() << \"Parameter \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n\r\n        // Disable program\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(program)));\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, float x, float y)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Enable program\r\n        GLint program;\r\n        glGetIntegerv(GL_CURRENT_PROGRAM, &program);\r\n\r\n        bool notActiveProgram = (static_cast<unsigned int>(program) != m_shaderProgram);\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(m_shaderProgram)));\r\n\r\n        // Get parameter location and assign it new values\r\n        GLint location = static_cast<GLint>(getParamLocation(name));\r\n        if (location != -1)\r\n            glCheck(glUniform2fARB(location, x, y));\r\n        else\r\n            err() << \"Parameter \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n\r\n        // Disable program\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(program)));\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, float x, float y, float z)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Enable program\r\n        GLint program;\r\n        glGetIntegerv(GL_CURRENT_PROGRAM, &program);\r\n\r\n        bool notActiveProgram = (static_cast<unsigned int>(program) != m_shaderProgram);\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(m_shaderProgram)));\r\n\r\n        // Get parameter location and assign it new values\r\n        GLint location = static_cast<GLint>(getParamLocation(name));\r\n        if (location != -1)\r\n            glCheck(glUniform3fARB(location, x, y, z));\r\n        else\r\n            err() << \"Parameter \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n\r\n        // Disable program\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(program)));\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, float x, float y, float z, float w)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Enable program\r\n        GLint program;\r\n        glGetIntegerv(GL_CURRENT_PROGRAM, &program);\r\n\r\n        bool notActiveProgram = (static_cast<unsigned int>(program) != m_shaderProgram);\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(m_shaderProgram)));\r\n\r\n        // Get parameter location and assign it new values\r\n        GLint location = static_cast<GLint>(getParamLocation(name));\r\n        if (location != -1)\r\n            glCheck(glUniform4fARB(location, x, y, z, w));\r\n        else\r\n            err() << \"Parameter \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n\r\n        // Disable program\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(program)));\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, const Vector2f& v)\r\n{\r\n    setParameter(name, v.x, v.y);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, const Vector3f& v)\r\n{\r\n    setParameter(name, v.x, v.y, v.z);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, const Color& color)\r\n{\r\n    setParameter(name, color.r / 255.f, color.g / 255.f, color.b / 255.f, color.a / 255.f);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, const sf::Transform& transform)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Enable program\r\n        GLint program;\r\n        glGetIntegerv(GL_CURRENT_PROGRAM, &program);\r\n\r\n        bool notActiveProgram = (static_cast<unsigned int>(program) != m_shaderProgram);\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(m_shaderProgram)));\r\n\r\n        // Get parameter location and assign it new values\r\n        GLint location = static_cast<GLint>(getParamLocation(name));\r\n        if (location != -1)\r\n            glCheck(glUniformMatrix4fvARB(location, 1, GL_FALSE, transform.getMatrix()));\r\n        else\r\n            err() << \"Parameter \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n\r\n        // Disable program\r\n        if(notActiveProgram) glCheck(glUseProgram(static_cast<GLuint>(program)));\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, const Texture& texture)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Find the location of the variable in the shader\r\n        int location = static_cast<GLint>(getParamLocation(name));\r\n        if (location == -1)\r\n        {\r\n            err() << \"Texture \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        // Store the location -> texture mapping\r\n        TextureTable::iterator it = m_textures.find(location);\r\n        if (it == m_textures.end())\r\n        {\r\n            // New entry, make sure there are enough texture units\r\n            static const GLint maxUnits = getMaxTextureUnits();\r\n            if (m_textures.size() + 1 >= static_cast<std::size_t>(maxUnits))\r\n            {\r\n                err() << \"Impossible to use texture \\\"\" << name << \"\\\" for shader: all available texture units are used\" << std::endl;\r\n                return;\r\n            }\r\n\r\n            m_textures[location] = &texture;\r\n        }\r\n        else\r\n        {\r\n            // Location already used, just replace the texture\r\n            it->second = &texture;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::setParameter(const std::string& name, CurrentTextureType)\r\n{\r\n    if (m_shaderProgram)\r\n    {\r\n        ensureGlContext();\r\n\r\n        // Find the location of the variable in the shader\r\n        m_currentTexture = static_cast<GLint>(getParamLocation(name));\r\n        if (m_currentTexture == -1)\r\n            err() << \"Texture \\\"\" << name << \"\\\" not found in shader\" << std::endl;\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::bind(const Shader* shader)\r\n{\r\n    ensureGlContext();\r\n\r\n    if (shader && shader->m_shaderProgram)\r\n    {\r\n        // Enable the program\r\n        glCheck(glUseProgram(static_cast<GLuint>(shader->m_shaderProgram)));\r\n\r\n        // Bind the textures\r\n        shader->bindTextures();\r\n\r\n        // Bind the current texture\r\n        if (shader->m_currentTexture != -1)\r\n            glCheck(glUniform1iARB(shader->m_currentTexture, 0));\r\n    }\r\n    else\r\n    {\r\n        // Bind no shader\r\n        glCheck(glUseProgram(0));\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::isAvailable()\r\n{\r\n    ensureGlContext();\r\n\r\n    // Make sure that GLEW is initialized\r\n    priv::ensureGlewInit();\r\n\r\n    return GLEW_ARB_shading_language_100 &&\r\n           GLEW_ARB_shader_objects       &&\r\n           GLEW_ARB_vertex_shader        &&\r\n           GLEW_ARB_fragment_shader;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nbool Shader::compile(const char* vertexShaderCode, const char* fragmentShaderCode)\r\n{\r\n    ensureGlContext();\r\n\r\n    // First make sure that we can use shaders\r\n    if (!isAvailable())\r\n    {\r\n        err() << \"Failed to create a shader: your system doesn't support shaders \"\r\n              << \"(you should test Shader::isAvailable() before trying to use the Shader class)\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    // Destroy the shader if it was already created\r\n    if (m_shaderProgram)\r\n        glCheck(glDeleteObjectARB(m_shaderProgram));\r\n\r\n    m_params.clear();\r\n\r\n    // Create the program\r\n    m_shaderProgram = glCreateProgramObjectARB();\r\n\r\n    // Create the vertex shader if needed\r\n    if (vertexShaderCode)\r\n    {\r\n        // Create and compile the shader\r\n        GLhandleARB vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);\r\n        glCheck(glShaderSourceARB(vertexShader, 1, &vertexShaderCode, NULL));\r\n        glCheck(glCompileShaderARB(vertexShader));\r\n\r\n        // Check the compile log\r\n        GLint success;\r\n        glCheck(glGetObjectParameterivARB(vertexShader, GL_OBJECT_COMPILE_STATUS_ARB, &success));\r\n        if (success == GL_FALSE)\r\n        {\r\n            char log[1024];\r\n            glCheck(glGetInfoLogARB(vertexShader, sizeof(log), 0, log));\r\n            err() << \"Failed to compile vertex shader:\" << std::endl\r\n                  << log << std::endl;\r\n            glCheck(glDeleteObjectARB(vertexShader));\r\n            glCheck(glDeleteObjectARB(m_shaderProgram));\r\n            m_shaderProgram = 0;\r\n            return false;\r\n        }\r\n\r\n        // Attach the shader to the program, and delete it (not needed anymore)\r\n        glCheck(glAttachObjectARB(m_shaderProgram, vertexShader));\r\n        glCheck(glDeleteObjectARB(vertexShader));\r\n    }\r\n\r\n    // Create the fragment shader if needed\r\n    if (fragmentShaderCode)\r\n    {\r\n        // Create and compile the shader\r\n        GLhandleARB fragmentShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);\r\n        glCheck(glShaderSourceARB(fragmentShader, 1, &fragmentShaderCode, NULL));\r\n        glCheck(glCompileShaderARB(fragmentShader));\r\n\r\n        // Check the compile log\r\n        GLint success;\r\n        glCheck(glGetObjectParameterivARB(fragmentShader, GL_OBJECT_COMPILE_STATUS_ARB, &success));\r\n        if (success == GL_FALSE)\r\n        {\r\n            char log[1024];\r\n            glCheck(glGetInfoLogARB(fragmentShader, sizeof(log), 0, log));\r\n            err() << \"Failed to compile fragment shader:\" << std::endl\r\n                  << log << std::endl;\r\n            glCheck(glDeleteObjectARB(fragmentShader));\r\n            glCheck(glDeleteObjectARB(m_shaderProgram));\r\n            m_shaderProgram = 0;\r\n            return false;\r\n        }\r\n\r\n        // Attach the shader to the program, and delete it (not needed anymore)\r\n        glCheck(glAttachObjectARB(m_shaderProgram, fragmentShader));\r\n        glCheck(glDeleteObjectARB(fragmentShader));\r\n    }\r\n\r\n    // Link the program\r\n    glCheck(glLinkProgramARB(m_shaderProgram));\r\n\r\n    // Check the link log\r\n    GLint success;\r\n    glCheck(glGetObjectParameterivARB(m_shaderProgram, GL_OBJECT_LINK_STATUS_ARB, &success));\r\n    if (success == GL_FALSE)\r\n    {\r\n        char log[1024];\r\n        glCheck(glGetInfoLogARB(m_shaderProgram, sizeof(log), 0, log));\r\n        err() << \"Failed to link shader:\" << std::endl\r\n              << log << std::endl;\r\n        glCheck(glDeleteObjectARB(m_shaderProgram));\r\n        m_shaderProgram = 0;\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nvoid Shader::bindTextures() const\r\n{\r\n    TextureTable::const_iterator it = m_textures.begin();\r\n    for (std::size_t i = 0; i < m_textures.size(); ++i)\r\n    {\r\n        GLint index = static_cast<GLsizei>(i + 1);\r\n        glCheck(glUniform1iARB(it->first, index));\r\n        glCheck(glActiveTextureARB(GL_TEXTURE0_ARB + index));\r\n        Texture::bind(it->second);\r\n        ++it;\r\n    }\r\n\r\n    // Make sure that the texture unit which is left active is the number 0\r\n    glCheck(glActiveTextureARB(GL_TEXTURE0_ARB));\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\nint Shader::getParamLocation(const std::string& name)\r\n{\r\n    std::map<std::string, int>::iterator it;\r\n\r\n    if((it = m_params.find(name)) != m_params.end())\r\n    {\r\n        return it->second;\r\n    }\r\n    else\r\n    {\r\n        int location = static_cast<int>(glGetUniformLocationARB(m_shaderProgram, name.c_str()));\r\n        if (location != -1)\r\n            m_params.insert(std::make_pair(name, location));\r\n\r\n        return location;\r\n    }\r\n}\r\n\r\n} // namespace sf\r\n"]],"start1":0,"start2":0,"length1":0,"length2":20420}]],"length":20420}
{"contributors":[],"silentsave":false,"ts":1369223133221,"patch":[[{"diffs":[[0,"rator it"],[1," = m_params.lower_bound(name)"],[0,";\r\n\r\n   "]],"start1":20046,"start2":20046,"length1":16,"length2":45}]],"length":20449,"saved":false}
{"ts":1369223343154,"patch":[[{"diffs":[[0," if((it "],[1,"!"],[0,"= m_para"]],"start1":20091,"start2":20091,"length1":16,"length2":17},{"diffs":[[0,"ams."],[-1,"find(name)) != m_params.end("],[1,"end() && !(m_params.key_compare()(name, it->first)"],[0,"))\r\n"]],"start1":20107,"start2":20107,"length1":36,"length2":58}]],"length":20472,"saved":false}
{"ts":1369223566473,"patch":[[{"diffs":[[0,"    "],[-1,"std::map<std::string, int>"],[1,"ParameterCache"],[0,"::it"]],"start1":20011,"start2":20011,"length1":34,"length2":22},{"diffs":[[0,"ert("],[-1,"std::make_pair"],[1,"it, ParameterCache::value_type"],[0,"(nam"]],"start1":20363,"start2":20363,"length1":22,"length2":38}]],"length":20476,"saved":false}
